import conans
import sys
from pathlib import Path
from itertools import chain
from typing import Dict, List

from conans.model import Generator
from conans.client.output import ConanOutput


class LibMan(Generator):
    def __init__(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)
        self.log = ConanOutput(sys.stderr)

    @property
    def filename(self):
        pass

    def _generate_package_file(self, name: str, dep: conans.model.build_info.CppInfo) -> str:
        lines = [
            '# libman package file generated by Conan',
            'Type: Package',
            f'Name: {name}',
            f'Namespace: {name}',
            f'Library: {name}/lib.lml',
        ]
        for req in dep.public_deps:
            lines.append(f'Requires: {req}')

        return '\n'.join(lines)

    def _add_lib(self, lines: List[str], lib: str, lib_paths: List[str]):
        if lib == 'pthread':
            self.log.info('Found link to `pthread`. Adding special requirement "Threading"')
            lines.append(f'Special-Uses: Threading')
            return
        for libdir in lib_paths:
            libdir = Path(libdir)
            candidates = chain(
                libdir.glob(f'lib{lib}.a'),
                libdir.glob(f'lib{lib}.lib'),
                libdir.glob(f'lib{lib}.so'),
                libdir.glob(f'{lib}.dll'),
            )
            for cand in candidates:
                lines.append(f'Path: {cand}')
                self.log.info(f'Selected {cand} as linkable for {lib}')
                return
        raise RuntimeError(f'No linkable for "{lib}"" in search directories {lib_paths}')

    def _generate_library_files(self, name: str, dep: conans.model.build_info.CppInfo) -> Dict[str, str]:
        fname = f'{name}/lib.lml'
        lines = [
            f'# Library file generated for {name} by Conan',
            f'Type: Library',
            f'Name: {name}',
        ]
        for inc in dep.include_paths:
            lines.append(f'Include-Path: {inc}')
        for def_ in dep.defines:
            lines.append(f'Preprocessor-Define: {def_}')
        for lib in dep.libs:
            self._add_lib(lines, lib, dep.lib_paths)
        return {f'lm/{fname}': '\n'.join(lines)}

    def _generate_one_dep(self, name: str, dep: conans.model.build_info.CppInfo) -> str:
        pkg_file = self._generate_package_file(name, dep)
        lmp_path = f'lm/{name}.lmp'
        ret = {
            lmp_path: pkg_file,
        }
        ret.update(self._generate_library_files(name, dep))
        return ret, lmp_path

    def _generate_from_deps_info(self, deps: conans.model.build_info.DepsCppInfo) -> Dict[str, str]:
        ret = {}
        index_lines = [
            'Type: Index',
        ]
        for name, depinfo in deps.dependencies:
            more, lmp_path = self._generate_one_dep(name, depinfo)
            ret.update(more)
            index_lines.append(f'Package: {name}; {lmp_path}')
        ret['conan.lmi'] = '\n'.join(index_lines)
        lm_pkg_dir = self.deps_build_info['libman-generator'].rootpath
        libman_cmake = (Path(lm_pkg_dir) / 'libman.cmake').read_text()
        libman_cmake += r'''
        set(LIBMAN_INDEX "${CMAKE_CURRENT_LIST_DIR}/conan.lmi" CACHE INTERNAL "Path to Conan-generated LibMan index")
        '''
        ret['conan-libman.cmake'] = libman_cmake
        return ret

    @property
    def content(self):
        files = self._generate_from_deps_info(self.deps_build_info)
        return files


class ConanFile(conans.ConanFile):
    name = 'libman-generator'
    version = '0.1.0'
    generators = 'txt'
    exports_sources = '*', '../../cmake/libman.cmake'

    requires = (
        'catch2/2.3.0@bincrafters/stable',
        'spdlog/1.1.0@bincrafters/stable',
    )

    def package(self):
        super().package()
        self.copy('libman.cmake')
