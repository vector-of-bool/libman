import conans
import sys
from pathlib import Path
from itertools import chain
from typing import Dict, List

from conans.model import Generator
from conans.client.output import ConanOutput


class LibMan(Generator):
    def __init__(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)
        self.log = ConanOutput(sys.stderr)

    @property
    def filename(self):
        pass

    def _generate_package_file(self, name: str, dep: conans.model.build_info.CppInfo) -> str:
        lines = [
            '# libman package file generated by Conan',
            'Type: Package',
            f'Name: {name}',
            f'Namespace: {name}',
            f'Library: {name}/lib.lml',
        ]
        for req in dep.public_deps:
            lines.append(f'Requires: {req}')

        return '\n'.join(lines)

    def _add_lib(self, lines: List[str], lib: str, lib_paths: List[str]):
        if lib == 'pthread':
            self.log.info('Found link to `pthread`. Adding special requirement "Threading"')
            lines.append(f'Special-Uses: Threading')
            return
        for libdir in lib_paths:
            libdir = Path(libdir)
            candidates = chain(
                libdir.glob(f'lib{lib}.a'),
                libdir.glob(f'lib{lib}.lib'),
                libdir.glob(f'lib{lib}.so'),
                libdir.glob(f'{lib}.dll'),
            )
            for cand in candidates:
                lines.append(f'Path: {cand}')
                self.log.info(f'Selected {cand} as linkable for {lib}')
                return
        raise RuntimeError(f'No linkable for "{lib}"" in search directories {lib_paths}')

    def _generate_library_files(self, name: str, dep: conans.model.build_info.CppInfo) -> Dict[str, str]:
        fname = f'{name}/lib.lml'
        lines = [
            f'# Library file generated for {name} by Conan',
            f'Type: Library',
            f'Name: {name}',
        ]
        for inc in dep.include_paths:
            lines.append(f'Include-Path: {inc}')
        for def_ in dep.defines:
            lines.append(f'Preprocessor-Define: {def_}')
        for lib in dep.libs:
            self._add_lib(lines, lib, dep.lib_paths)
        return {f'lm/{fname}': '\n'.join(lines)}

    def _generate_one_dep(self, name: str, dep: conans.model.build_info.CppInfo) -> str:
        pkg_file = self._generate_package_file(name, dep)
        lmp_path = f'lm/{name}.lmp'
        ret = {
            lmp_path: pkg_file,
        }
        ret.update(self._generate_library_files(name, dep))
        return ret, lmp_path

    def _generate_from_deps_info(self, deps: conans.model.build_info.DepsCppInfo) -> Dict[str, str]:
        ret = {}
        index_lines = [
            'Type: Index',
        ]
        for name, depinfo in deps.dependencies:
            more, lmp_path = self._generate_one_dep(name, depinfo)
            ret.update(more)
            index_lines.append(f'Package: {name}; {lmp_path}')
        ret['conan.lmi'] = '\n'.join(index_lines)
        lm_pkg_dir = self.deps_build_info['libman-generator'].rootpath
        libman_cmake = (Path(lm_pkg_dir) / 'libman.cmake').read_text()
        libman_cmake += r'''
        set(LIBMAN_INDEX "${CMAKE_CURRENT_LIST_DIR}/conan.lmi" CACHE INTERNAL "Path to Conan-generated LibMan index")
        '''
        ret['conan-libman.cmake'] = libman_cmake
        return ret

    @property
    def content(self):
        files = self._generate_from_deps_info(self.deps_build_info)
        return files


def _fill_user_info_cmake(
        cf: conans.ConanFile,
        index: 'libman.data.Index',
        user_info: conans.model.user_info.UserInfo,
        args: dict,
):
    targets_file_path = cf.build_folder / Path(
        args.pop('targets_file', 'targets.cmake'))
    tf_content = targets_file_path.read_text()
    add_lib_re = re.compile(r'add_library\((?P<name>\S+) \w+ IMPORTED\)')
    libs = []
    for mat in add_lib_re.finditer(tf_content):
        name = mat.group('name')
        cf.output.info(f'Exporting CMake-generate library `{name}`')
        libs.append(name)

    set_properties_call_re = re.compile(
        r'set_target_properties\((\S+) PROPERTIES[\s\n]+(.*?)[\s\n]+\)',
        re.MULTILINE)
    lib_data = {
        n: {
            'uses': [],
            'links': [],
            'special-uses': [],
            'path': None,
        }
        for n in libs
    }
    pkg_requires = set()

    link_only_re = re.compile(r'\$<LINK_ONLY:(.*)>')
    ns_target_re = re.compile(r'(\S+?)::(\S+)')

    knowns_libs = {}
    for pkg in index:
        pkg = libman.parse.parse_package_file(pkg.path)
        namespace = pkg.namespace
        for lib in pkg.libraries:
            lib = libman.parse.parse_library_file(lib)
            knowns_libs[(pkg.name, lib.name)] = {
                'library': lib,
                'package': pkg,
            }

    def parse_namespaced_lib(target: str, dest: List[str], namespace: str,
                             lib: str):
        found = knowns_libs.get((namespace, lib))
        if not found:
            cf.output.warn(
                f'Target `{target}` links to known library `{namespace}::{lib}`'
            )
            return
        pkg_requires.add(found['package'].name)
        dest.append(f'{namespace}/{lib}')

    def parse_single_lib(target: str, lib: str):
        mat = link_only_re.match(lib)
        key = 'uses'
        if mat:
            lib = mat.group(1)
            key = 'links'

        dest = lib_data[target]
        specials = dest['special-uses']
        if lib == 'Threads::Threads':
            specials.append('Threading')
        elif lib == 'm':
            specials.append('Math')
        elif lib == 'dl':
            specials.append('DynamicLinking')
        else:
            mat = ns_target_re.match(lib)
            if not mat:
                cf.output.warn(
                    f'Target "{target}" links to non-Conan library {lib}')
            pkg_namespace, pkg_lib = mat.groups()
            parse_namespaced_lib(target, dest[key], pkg_namespace, pkg_lib)

    def parse_link_libs(target: str, libs: str):
        libs = [l for l in libs.split(';') if l]
        for l in libs:
            parse_single_lib(target, l)

    for mat in set_properties_call_re.finditer(tf_content):
        libname = mat.group(1)
        prop_args = shlex.split(mat.group(2).replace('\\$', '$'))
        cf.output.info(f'Set properties: {prop_args}')
        while prop_args:
            key, value, prop_args = prop_args[0], prop_args[1], prop_args[2:]
            if key == 'INTERFACE_LINK_LIBRARIES':
                parse_link_libs(libname, value)

    cf.output.info(lib_data)
    return {
        'libraries': lib_data,
        'requires': pkg_requires,
    }


def fill_user_info(cf: conans.ConanFile, mode, **kwargs):
    _libman_check()

    index_file_path = Path(cf.build_folder) / 'conan.lmi'
    if not index_file_path.exists():
        raise RuntimeError(
            'No conan.lmi index file was found. Did you run the libman Conan generator?'
        )
    user_info: conans.model.user_info.DepsUserInfo = cf.user_info
    index: libman.data.Index = libman.parse.parse_index_file(index_file_path)
    cf.output.info('Exporting libman linking information')

    if mode == 'cmake':
        ret = _fill_user_info_cmake(cf, index, user_info, kwargs)

    for k in kwargs:
        cf.output.warn(f'Unknown keyword argument to fill_user_info(): {k}')

    return ret


class ConanFile(conans.ConanFile):
    name = 'libman-generator'
    version = '0.1.0'
    generators = 'txt'
    exports_sources = '*', '../../cmake/libman.cmake'

    requires = (
        'catch2/2.3.0@bincrafters/stable',
        'spdlog/1.1.0@bincrafters/stable',
    )

    def package(self):
        super().package()
        self.copy('libman.cmake')
